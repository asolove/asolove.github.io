---
layout: post
title: "Pure UI Control"
date: 2017-03-04 21:43:39
categories: js service-worker stream
---

### This month marks 10 years that I’ve been paid to build web user interfaces. And today is the second anniversary of Guillermo Rauch’s essay <a href="https://rauchg.com/2015/pure-ui" data-href="https://rauchg.com/2015/pure-ui" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Pure UI</a>. Those two anniversaries have led me to reflect on the past and future of UI development.

The past 10 years has seen major improvements in how cross-discipline teams work together to create interfaces. We are much better at thinking about all the different ways an interface should display, depending on the user, their data, their device, and other context.</p><p name="7af0" id="7af0" class="graf graf--p graf-after--p">In contrast, we still struggle to understand how complex interfaces behave given all the possible ways that users interact with them. Most interfaces still have bugs when you interact with them in unexpected ways. Even the developers don’t fully understand their behavior. We can do better.</p><p name="429a" id="429a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Understandable behavior is possible.</strong> We can improve how teams understand a UI’s interactive behavior by following the same strategy that helped us understand complex UI display states.</p><p name="249d" id="249d" class="graf graf--p graf-after--p">In this post, I’d like to show that:</p><ul class="postList"><li name="3346" id="3346" class="graf graf--li graf-after--p">Teams improved at building complex UIs by changing the way they represented and communicated about them.</li><li name="ce40" id="ce40" class="graf graf--li graf-after--li">Unexpected behavior arises because teams struggle to represent an interface’s desired behavior.</li><li name="a4a4" id="a4a4" class="graf graf--li graf-after--li graf--trailing">By adopting the idea of <em class="markup--em markup--li-em">control state</em>, teams can gain a powerful way to represent a UI’s interactions and prevent unexpected behavior.</li></ul></div></div></section><section name="cbcf" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1f4f" id="1f4f" class="graf graf--h3 graf--leading">Understanding display states with Pure UI</h3><p name="ba76" id="ba76" class="graf graf--p graf-after--h3">In his wonderful essay <a href="https://rauchg.com/2015/pure-ui" data-href="https://rauchg.com/2015/pure-ui" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Pure UI</a>, Guillermo Rauch described how the React programming model changed his collaboration with designers. The major change is a focus on explicitly describing <em class="markup--em markup--p-em">display states</em>. The designer creates an artboard with side-by-side designs of each of the widget’s states. The React code similarly branches on those same states. There is a close correspondence between between each design on the artboard and the code in the <code class="markup--code markup--p-code">render</code> method. More importantly, the shared language of states means that when the developer discovers a new possible case, it has a natural place on the design artboard and requires only one new bit of thought from both design and development.</p><p name="c099" id="c099" class="graf graf--p graf-after--p">This way of working is now so natural that it’s easy to forget that it wasn’t always obvious. To see the difference, let’s consider how designers and developers worked together when I started building web UIs ten years ago.</p><p name="e8ef" id="e8ef" class="graf graf--p graf-after--p">The design was a Photoshop file with just a single state of the screen visible. A thoughtful designer might have considered a few other states and put them in layer groups to be switched on and off. But many other states were ignored or described only in informal conversation, as changes to be made to the original state. The secondary states never took on visual form and were therefore a frequent topic of miscommunication.</p><p name="f7e9" id="f7e9" class="graf graf--p graf-after--p">The code for the widget consisted of a template, and then a series of functions that described how to modify the displayed DOM in response to various user inputs or data changes.</p><p name="598d" id="598d" class="graf graf--p graf-after--p">These design and code representations share two features:</p><ul class="postList"><li name="d331" id="d331" class="graf graf--li graf-after--p">Different states of the application can be viewed only one at a time, and require careful manipulation to reach.</li><li name="a867" id="a867" class="graf graf--li graf-after--li">There is no explicit list of possible states.</li></ul><p name="c4cb" id="c4cb" class="graf graf--p graf-after--li">These features make it hard for the team to think and communicate about the interface:</p><ul class="postList"><li name="1dd8" id="1dd8" class="graf graf--li graf-after--p">There’s no easy way to see all the states at once, so it’s difficult to hold the interface as a whole in your head.</li><li name="6af2" id="6af2" class="graf graf--li graf-after--li">Without an explicit list of states, it’s easy to incorrectly judge progress if the default state looks finished.</li><li name="028f" id="028f" class="graf graf--li graf-after--li">When developers discover a new state, it doesn’t have a natural place in the design document, so often isn’t designed at all.</li><li name="2982" id="2982" class="graf graf--li graf-after--li">Adding a new design element to the interface becomes progressively harder because every transition method needs to consider whether it should show, hide, or make changes to every element.</li></ul><p name="e2c0" id="e2c0" class="graf graf--p graf-after--li">Notice that these aren’t primarily technical or process problems. They’re thinking problems. The design and the code describe a component as a default visual display and a set of changes that can be applied to it. But these representations don’t help us communicate across disciplines, identify questions that we still need to answer, or simplify the work itself.</p><p name="0aed" id="0aed" class="graf graf--p graf-after--p">The Pure UI approach improved our thinking and communication by first changing the way we represented display states. Now we describe a component as a set of states that each have their own visual display. This description provides a natural mapping between the designer’s artboard and the developer’s style guide. Both of these artifacts allow us see all the states side-by-side, so we can think about them as a whole and notice inconsistencies and open questions. They also make changes atomic and localized: when we make a change to one state, it only affects that state.</p><p name="b369" id="b369" class="graf graf--p graf-after--p">Generalizing the lessons of Pure UI, we can see a strategy to apply whenever a problem becomes too complex for teams to think and communicate about together:</p><ul class="postList"><li name="ec4f" id="ec4f" class="graf graf--li graf-after--p">Look for a missing idea not explicitly reflected in the problem’s current representation.</li><li name="4f74" id="4f74" class="graf graf--li graf-after--li">Find a new representation that makes that idea explicit and helps us represent what we know and what we still need to think through.</li><li name="c8cb" id="c8cb" class="graf graf--li graf-after--li">Then, only at the end, worry about the technology and process to use to bring this representation to life.</li></ul><p name="4b86" id="4b86" class="graf graf--p graf-after--li graf--trailing">Keep that strategy in mind as we consider the problem that many UI teams currently struggle with: understanding all the possible interactive behaviors of their application.</p></div></div></section><section name="da9e" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4aa3" id="4aa3" class="graf graf--h3 graf--leading">The problem of unexpected behavior</h3><p name="bd88" id="bd88" class="graf graf--p graf-after--h3">For as long as I’ve built interfaces, regardless of the technology or testing plan, we’ve found unexpected behavior in production. Nothing obvious, certainly nothing that anyone would have written a user story about.</p><p name="6191" id="6191" class="graf graf--p graf-after--p">Instead, the bugs came up in unexpected cases that made you wonder “why would anyone do <em class="markup--em markup--p-em">that</em>?” But if it’s possible to do something, someone eventually will. What almost all of these bugs had in common was a dependence on <em class="markup--em markup--p-em">ordering </em>and <em class="markup--em markup--p-em">cases</em>, especially <em class="markup--em markup--p-em">unexpected </em>orders of cases.</p><p name="e5c9" id="e5c9" class="graf graf--p graf-after--p">You’ve probably experienced bugs like these in your own projects:</p><ul class="postList"><li name="37d7" id="37d7" class="graf graf--li graf-after--p">The credit card validation widget stops working if you enter half of a card number, switch to another screen in the application, do something there, and then switch back to the payment screen.</li><li name="4c4c" id="4c4c" class="graf graf--li graf-after--li">If you’re in the middle of editing one object, click a button to load data about another, and if the timing of the response is just right, your edits may be saved to the wrong one. Or lost forever.</li></ul><p name="4749" id="4749" class="graf graf--p graf-after--li">Sometimes I see teams blame these problems on their own bad code, <code class="markup--code markup--p-code">redux-thunk</code>, or some other bit of technology. But it isn’t asynchronous tools or lazy developers that create these problems. It’s true that once you understand how the bug can happen, it’s obvious that the code is wrong. But when writing the code, would a reasonable developer have thought to handle this case? Did a designer consider this possibility and what should happen?</p><p name="3248" id="3248" class="graf graf--p graf-after--p">Usually not.</p><p name="c3b7" id="c3b7" class="graf graf--p graf-after--p">So we don’t have a technology or laziness problem, we have a thinking problem. We need representations that can help us think about an interface’s behavior.</p><figure name="5a18" id="5a18" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*gq6Pv_BHE2zALG6rgiCgJw.png" data-width="194" data-height="212" src="https://cdn-images-1.medium.com/max/800/1*gq6Pv_BHE2zALG6rgiCgJw.png"></figure><p name="518b" id="518b" class="graf graf--p graf-after--figure">Let’s consider a simple calculator application. It has only one display state, but a surprising depth of behavior. Everyone knows in general what it should do, but unless you’ve sat down to think about it, you likely don’t know <em class="markup--em markup--p-em">how</em> it should do it. It’s trickier than it looks.</p><p name="3c0c" id="3c0c" class="graf graf--p graf-after--p">You probably don’t believe me. You think you could turn this out in five minutes. I encourage you to go try. (Please leave a comment here with a link to the code and how long it took.)</p><p name="00dd" id="00dd" class="graf graf--p graf-after--p">Let’s examine the artifacts that a UI team would use to think about this interface:</p><p name="7289" id="7289" class="graf graf--p graf-after--p">A designer, after producing one simple mockup, might stop there. If very thoughtful, they might write a few sentences about the expected behavior for a few sequences of input.</p><p name="6235" id="6235" class="graf graf--p graf-after--p">The developer will quickly get the display and events hooked up. I’ll assume they use a pattern like Redux or the Elm architecture where they need to define a function that takes the current state and an action and returns a new state.</p><ul class="postList"><li name="688f" id="688f" class="graf graf--li graf-after--p">First they implement an action for the digits. A simple implementation just multiplies the existing value by 10 and adds the new digit.</li><li name="6a36" id="6a36" class="graf graf--li graf-after--li">Next they implement the decimal action. This doesn’t immediately change the numerical value but does need to show up on the display. So perhaps they add a new <code class="markup--code markup--li-code">decimalPressed</code> flag to the state. It’s set to true when decimal is pressed, and it causes the decimal point to show on the display even if the current value is integral. After this, the sequence of actions <code class="markup--code markup--li-code">2 0 .</code> correctly shows <code class="markup--code markup--li-code">20.</code> on the display.</li><li name="cb7e" id="cb7e" class="graf graf--li graf-after--li">Ah, but now a problem. When the <code class="markup--code markup--li-code">decimalPressed</code> flag is set to true, the existing handler for typing a digit is wrong. So any action that changes the number needs to check the flag. Oh, and any action that means we’re starting to type a new number needs to remember to set it back to false. Well, unless we pressed decimal right before the digit, then it should stay true. …</li></ul><p name="af38" id="af38" class="graf graf--p graf-after--li">There are better and worse ways to implement the complete logic and I don’t want to walk through the whole problem. The naive strategy is to slowly add flags and other non-visible bits of state to represent what each action needs to know about the history of past actions. This is workable, but creates problems:</p><ul class="postList"><li name="fa51" id="fa51" class="graf graf--li graf-after--p">Adding new actions becomes progressively harder because they may need to react to arbitrary previous actions or influence arbitrary future ones. It’s not clear which combinations you need to consider, or when you’re done.</li><li name="b57f" id="b57f" class="graf graf--li graf-after--li">The nested conditions in the code don’t clearly match to any other representation, so code itself becomes the definition of correctness. It becomes difficult for designers, or anyone else, to have opinions about what should happen in any particular case.</li><li name="3890" id="3890" class="graf graf--li graf-after--li">There’s no way to know if you’re done. Unit tests can cover cases you think about. But there are infinite possible orderings of events, so can they cover everything?</li></ul><p name="96a4" id="96a4" class="graf graf--p graf-after--li graf--trailing">Clearly this is not a technical problem, but a thinking one. In particular, the representation of behavior as prose or reducer code doesn’t help us to think about the problem or check our understanding. Just as in the case of Pure UI’s display states, we need a new organizing idea and a new representation to aid our understanding.</p></div></div></section><section name="63b9" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a2e1" id="a2e1" class="graf graf--h3 graf--leading">Data state &amp; control state</h3><p name="9e95" id="9e95" class="graf graf--p graf-after--h3">I think the idea we’re missing is an application’s <em class="markup--em markup--p-em">control states</em>. Previously we enumerated all of an interface’s <em class="markup--em markup--p-em">display states</em> as all the meaningfully different ways it should display. A <em class="markup--em markup--p-em">control state </em>is all the possible states of the interface that have different sets of allowed interactions. Sometimes the two layers of states align, as in a loading state that displays a spinner and ignores all user input. In other cases, an interface’s display state can remain the same even while it’s control state changes.</p><p name="4fc2" id="4fc2" class="graf graf--p graf-after--p">Consider the calculator. When its display reads <code class="markup--code markup--p-code">20</code>, it may actually be in one of two control states. In the “Entering operand” control state, typing another digit appends it to the end of the current number. In the “Result” control state (where a previously-calculated answer is shown), typing a digit causes it to be the start of a new operand, and transitions the control state to “Entering operand,” changing how the next action will be interpreted.</p><figure name="80e7" id="80e7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0smAw31yiwO7aEriW3NXrA.jpeg" data-width="600" data-height="784" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*0smAw31yiwO7aEriW3NXrA.jpeg"><figcaption class="imageCaption">The high-level statechart for the calculator application. © Addison Wessley. From Ian Horrocks’ “Constructing the User Interface with Statecharts”, p215.</figcaption></figure><p name="42ac" id="42ac" class="graf graf--p graf-after--figure">With the new idea of control state, we can proceed just as we did before, by imagining sequences of inputs and asking what the interface should be able to respond to next. But now we can take what we learn and make it into an enumerated set of all the allowed control states and how they respond to user actions.</p><p name="df16" id="df16" class="graf graf--p graf-after--p">Thinking about our interface’s behavior in terms of control states also makes it possible to produce more understandable artifacts. Non-programmers can easily follow a state transition diagram like the one at left for the calculator. Even for programmers, the visual structure of the chart may provide a high-level “aha!” understanding of what the interface really allows.</p><p name="9406" id="9406" class="graf graf--p graf-after--p">Control states also can be naturally represented in our code. No longer should we define a single handler for each button, with lots of cases inside it depending on the action history. Instead, transitions are defined for a specific pair of the current control state and the action.</p><p name="3069" id="3069" class="graf graf--p graf-after--p">If your language supports some kind of pattern matching, this can turn into quite lovely code. Below is part of an implementation of the calculator’s control states in <a href="http://facebook.github.io/reason/" data-href="http://facebook.github.io/reason/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Reason</a>. Each line communicates how a specific control state reacts to a specific action by returning a new control state.</p><p name="b22f" id="b22f" class="graf graf--p graf-after--p">(<em class="markup--em markup--p-em">An aside to Reason aficionados: </em>Notice an extra benefit of this structure, that each control state requires a specific, typed set of context data. This ensures that each state can only rely on data it is guaranteed to have, and that on leaving one state, any no-longer-active data is discarded and re-initialized when the state is re-entered. You may enjoy reading <a href="https://github.com/asolove/restate/blob/c93fb84ea6bf39fb9722cd7593ac7c636d35c9e1/motivation/naive/calculator_state.re#L43" data-href="https://github.com/asolove/restate/blob/c93fb84ea6bf39fb9722cd7593ac7c636d35c9e1/motivation/naive/calculator_state.re#L43" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the full code</a>.)</p><figure name="c843" id="c843" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CFqSy8oH0ntTmiBLDGFzaA.jpeg" data-width="1376" data-height="580" src="https://cdn-images-1.medium.com/max/800/1*CFqSy8oH0ntTmiBLDGFzaA.jpeg"></figure><p name="eb62" id="eb62" class="graf graf--p graf-after--figure">You don’t have to understand the details of Reason as a language to see that this code, even if translated to your language of choice, maps quite naturally to the diagram above. If a designer adds a new line to the diagram, it corresponds clearly to one spot in the code. And if a developer adds a new transition in the code, it has a natural place on the diagram.</p><p name="9d42" id="9d42" class="graf graf--p graf-after--p">There is still a lot of thought required in the design of the control states. But they provide an organizing structure that allows for more natural representations of our thought. As a result, questions that used to require detailed thought can be reduced to simple visual perception. Cases that developers previously struggled to explain to designers now just require pointing.</p><p name="54c9" id="54c9" class="graf graf--p graf-after--p graf--trailing">The team can <em class="markup--em markup--p-em">think together</em> about their interface’s behavior.</p></div></div></section><section name="1813" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6841" id="6841" class="graf graf--h3 graf--leading">Summary</h3><p name="ef42" id="ef42" class="graf graf--p graf-after--h3">Over the past few years, web teams have adopted new state-centric representations for their design work. These representations made it easier to think about what an interface should look like depending on data and user context.</p><p name="cd6d" id="cd6d" class="graf graf--p graf-after--p">Despite that new way of working, most interfaces still have unexpected behavior when subjected to all the possible permutations of user interaction. Teams have no way to represent all these possibilities or to communicate about all the different ways their application needs to respond to sequences of input.</p><p name="e73e" id="e73e" class="graf graf--p graf-after--p graf--trailing">To solve this problem, teams can adopt the notion of <em class="markup--em markup--p-em">control state</em> as a description of all the states the interface can be in from the perspective of how it will respond to user interactions. By explicitly designing the graph of control states, they can arrive at an understandable, finite set of behaviors that the application needs to exhibit. With a consciously-designed control state space, teams can more easily reason about what they create together.</p></div></div></section><section name="de5a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="ba08" id="ba08" class="graf graf--h4 graf--leading">Any questions?</h4><p name="d24f" id="d24f" class="graf graf--p graf-after--h4"><em class="markup--em markup--p-em">The calculator is a simple example: does this approach scale to larger interfaces? </em>With simple state machines, things quickly grow too complicated. But a more powerful formalism, statecharts, can model more complex systems by allowing them to be decomposed into hierarchies (just like components, hmm…) and to represent several charts that can proceed concurrently with one another. Statecharts are a common method for modeling complex embedded software that has many more inputs, and less room for error, than our interfaces.</p><p name="5073" id="5073" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">What are the semantics of the diagram? How are control states best encoded in my language/framework? </em>I don’t know! I think there are lots of possible ways to use the idea of control states, just as there are many concrete ways that teams use display states to organize their work.</p><p name="684e" id="684e" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">That’s it? You wrote 2000 words to tell us about state machines? </em>Well, sort of. First, because many web developers don’t have a CS background, so just saying “state machines” doesn’t help them. Second, because I wanted to talk about the idea on a non-technical level. The benefit of statecharts comes from using them as a representation to aid cross-discipline thinking and communication. And hey, maybe hearing about it from a different angle will help developers, too.</p></div></div></section><section name="f585" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="84a5" id="84a5" class="graf graf--h4 graf--leading">Notes</h4><ul class="postList"><li name="7735" id="7735" class="graf graf--li graf-after--h4">I am very thankful to <a href="https://medium.com/u/9a6e84e34ca9" data-href="https://medium.com/u/9a6e84e34ca9" data-anchor-type="2" data-user-id="9a6e84e34ca9" data-action-value="9a6e84e34ca9" data-action="show-user-card" data-action-type="hover" class="markup--user markup--li-user" target="_blank">Kevin Lynagh</a>, who started bugging me about the idea of using statecharts in UI development almost three years ago. Despite my slow uptake, he kept raising the topic until I saw its value.</li><li name="e038" id="e038" class="graf graf--li graf-after--li">The calculator example and the statechart for its behavior come from Ian Horrocks’ book <a href="https://www.amazon.com/Constructing-User-Interface-Statecharts-Horrocks/dp/0201342782" data-href="https://www.amazon.com/Constructing-User-Interface-Statecharts-Horrocks/dp/0201342782" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><em class="markup--em markup--li-em">Constructing the User Interface with Statecharts</em></a>. The book was written in 1999, but his complaints about the poor technical design and confusing behavior of most UIs read like a complaint about web development in 2017. I hope we can improve before another 18 years pass.</li><li name="02cf" id="02cf" class="graf graf--li graf-after--li graf--trailing">The idea of focusing on how teams communicate and represent their work came from a happy coincidence. I reread “<a href="https://rauchg.com/2015/pure-ui" data-href="https://rauchg.com/2015/pure-ui" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Pure UI</a>”, for which I am very grateful to Guillermo, at the same time that I was reading Edwin Hutchins’ <a href="https://mitpress.mit.edu/books/cognition-wild" data-href="https://mitpress.mit.edu/books/cognition-wild" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><em class="markup--em markup--li-em">Cognition in the Wild</em></a>. Hutchins’ book is a critique of traditional cognitive science, arguing that humans mostly don’t use their critical thinking skills to solve problems. Instead, we adopt tools and representations that allow groups of people to solve what would be very complex cognitive problems with fairly minimal use of abstract reasoning. That critique could easily be pointed to normal discussion of programming. We praise the individual who by sheer force of thought arrives at a full understanding of a topic. But often all that effort would be avoidable with a good architecture diagram. I saw that the effect of Pure UI was to replace what had been a large amount of abstract thought with a more convenient representation. This led naturally to the question: what representation would help us understand behavior?</li></ul></div></div></section>

</section>
